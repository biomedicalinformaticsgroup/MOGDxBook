

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>preprocess_functions &mdash; Multi Omic Graph Diagnosis (MOGDx)</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/scripts/sphinx-book-theme.js"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
      <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../intro.html">
            
              <img src="../_static/mogdx.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Processing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Processing_in_R.html">Processing in R</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Processing_in_Python.html">Processing in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MOGDx Deployment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Executing_MOGDx.html">Executing MOGDx</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">MOGDx Model Types</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../MOGDx/Notebooks/MOGDx.html">MOGDx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MOGDx/Notebooks/MOGDx_PNet.html">MOGDx &amp; PNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MOGDx/Notebooks/MOGDx_NetGen.html">MOGDx Network Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MOGDx/Notebooks/MOGDx_Free.html">MOGDx Free</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Model Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Training_MOGDx.html">MOGDx Main Functions and Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contact.html">Contact Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../intro.html">Project name not set</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../intro.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">preprocess_functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for preprocess_functions</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">astropy.stats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pydeseq2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydeseq2.dds</span><span class="w"> </span><span class="kn">import</span> <span class="n">DeseqDataSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydeseq2.default_inference</span><span class="w"> </span><span class="kn">import</span> <span class="n">DefaultInference</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydeseq2.ds</span><span class="w"> </span><span class="kn">import</span> <span class="n">DeseqStats</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">palettable</span><span class="w"> </span><span class="kn">import</span> <span class="n">wesanderson</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpatches</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn.functional</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">F</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.optim</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">optim</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ElasticNet">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.ElasticNet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ElasticNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch module that implements an Elastic Net regularization logistic regression model.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        num_features (int): Number of features in the input dataset.</span>
<span class="sd">        num_classes (int): Number of classes in the output prediction.</span>
<span class="sd">        alpha (float): Mixing parameter for L1 (Lasso) and L2 (Ridge) regularization.</span>
<span class="sd">        lam (float): Overall regularization strength.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        linear (nn.Linear): Linear transformation layer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_features</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ElasticNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">num_features</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="n">lam</span>

<div class="viewcode-block" id="ElasticNet.forward">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.ElasticNet.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the neural network model that makes predictions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            X (torch.Tensor): Tensor containing input features.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Tensor containing the output logits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>


<div class="viewcode-block" id="ElasticNet.calculate_loss">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.ElasticNet.calculate_loss">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the combined cross-entropy and regularized loss for the model.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            logits (torch.Tensor): The logits as predicted by the model.</span>
<span class="sd">            y (torch.Tensor): The true labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The calculated loss value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_probs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">log_probs</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l1_reg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">l2_reg</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">l2_reg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">l1_reg</span><span class="p">)</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="n">likelihood</span> <span class="o">+</span> <span class="n">reg</span>
        <span class="k">return</span> <span class="n">total_loss</span></div>


<div class="viewcode-block" id="ElasticNet.accuracy">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.ElasticNet.accuracy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the accuracy of the model&#39;s predictions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            logits (torch.Tensor): The logits as predicted by the model.</span>
<span class="sd">            y (torch.Tensor): The true labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The calculated accuracy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">predicted</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="elastic_net">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.elastic_net">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">elastic_net</span><span class="p">(</span><span class="n">count_mtx</span> <span class="p">,</span> <span class="n">datMeta</span> <span class="p">,</span> <span class="n">train_index</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">,</span> <span class="n">val_index</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">,</span> <span class="n">l1_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">num_epochs</span><span class="o">=</span><span class="mi">1000</span> <span class="p">,</span> <span class="n">lam</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains an Elastic Net model given count data and metadata.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        count_mtx (pandas.DataFrame): Matrix containing gene expression or count data.</span>
<span class="sd">        datMeta (pandas.Series or DataFrame): Metadata corresponding to count_mtx samples.</span>
<span class="sd">        train_index (list, optional): Indexes for training samples.</span>
<span class="sd">        val_index (list, optional): Indexes for validation samples.</span>
<span class="sd">        l1_ratio (float, optional): The balance between L1 and L2 regularization.</span>
<span class="sd">        num_epochs (int, optional): Number of training epochs.</span>
<span class="sd">        lam (float, optional): Regularization strength.</span>
<span class="sd">        device (str, optional): Device to run the training on (&#39;cuda&#39; or &#39;cpu&#39;).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Extracted features based on weight importance.</span>
<span class="sd">        ElasticNet: Trained ElasticNet model.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># Initialize your model and the ElasticNet regularization term</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">num_features</span><span class="o">=</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_classes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">datMeta</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span> <span class="n">alpha</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># Define your loss function with ElasticNet regularization</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>

    <span class="c1"># Define your optimizer</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">datMeta</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="c1"># Inside your training loop</span>
    <span class="c1"># Initialize tqdm for epochs</span>
    <span class="n">epoch_progress</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Loss : &#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;epoch&#39;</span><span class="p">)</span>

    <span class="n">losses</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">calculate_loss</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">losses</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">losses</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Append data</span>
            <span class="n">losses</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">losses</span><span class="p">,</span> <span class="n">loss</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Update tqdm</span>
        <span class="n">epoch_progress</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loss : </span><span class="si">{</span><span class="n">losses</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">epoch_progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Close tqdm for epochs</span>
    <span class="n">epoch_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_train</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Model score : </span><span class="si">%1.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">score</span><span class="p">)</span>
    
    <span class="n">extracted_feats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="p">:</span> 
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">extracted_feats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">std</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">extracted_feats</span> <span class="p">,</span> <span class="n">model</span> </div>


<div class="viewcode-block" id="DESEQ">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.DESEQ">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">DESEQ</span><span class="p">(</span><span class="n">count_mtx</span> <span class="p">,</span> <span class="n">datMeta</span> <span class="p">,</span> <span class="n">condition</span> <span class="p">,</span> <span class="n">n_genes</span> <span class="p">,</span> <span class="n">train_index</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;parametric&#39;</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conducts differential expression analysis using DESeq2 algorithm.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        count_mtx (pandas.DataFrame): Count data for different genes.</span>
<span class="sd">        datMeta (pandas.DataFrame): Metadata for the samples in count_mtx.</span>
<span class="sd">        condition (str): Column in datMeta to use for condition separation.</span>
<span class="sd">        n_genes (int): Number of top genes to extract from the differential expression result.</span>
<span class="sd">        train_index (list, optional): Indexes for training samples if splitting is required.</span>
<span class="sd">        fit_type (str, optional): Statistical fitting type for VST transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        DeseqDataSet: An object containing results and configuration of DESeq2 run.</span>
<span class="sd">        numpy.ndarray: Variance Stabilized Transformed counts.</span>
<span class="sd">        list: Top genes identified in the differential expression analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">datMeta</span> <span class="o">=</span> <span class="n">datMeta</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">datMeta</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">datMeta</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span>
    
    <span class="n">inference</span> <span class="o">=</span> <span class="n">DefaultInference</span><span class="p">(</span><span class="n">n_cpus</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">dds</span> <span class="o">=</span> <span class="n">DeseqDataSet</span><span class="p">(</span>
        <span class="n">counts</span><span class="o">=</span><span class="n">count_mtx</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">datMeta</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">index</span><span class="p">],</span>
        <span class="n">design_factors</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span>
        <span class="n">refit_cooks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inference</span><span class="o">=</span><span class="n">inference</span><span class="p">,</span>
        <span class="c1"># n_cpus=8, # n_cpus can be specified here or in the inference object</span>
        <span class="p">)</span>
    
    <span class="n">dds</span><span class="o">.</span><span class="n">deseq2</span><span class="p">()</span>
    
    <span class="n">test</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subtest</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">datMeta</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span> <span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> 
        <span class="n">test</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">condition</span> <span class="p">,</span> <span class="n">subtest</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subtest</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">top_genes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subtest</span> <span class="ow">in</span> <span class="n">test</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Performing contrastive analysis for </span><span class="si">{</span><span class="n">subtest</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> vs. </span><span class="si">{</span><span class="n">subtest</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">stat_res</span> <span class="o">=</span> <span class="n">DeseqStats</span><span class="p">(</span><span class="n">dds</span><span class="p">,</span> <span class="n">contrast</span> <span class="o">=</span> <span class="n">subtest</span> <span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="n">inference</span><span class="p">)</span>
        <span class="n">stat_res</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">stat_res</span><span class="o">.</span><span class="n">results_df</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;padj&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">]</span>
        <span class="n">top_genes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;padj&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">n_genes</span><span class="p">]))</span>
        
    <span class="n">DeseqDataSet</span><span class="o">.</span><span class="n">vst</span><span class="p">(</span><span class="n">dds</span> <span class="p">,</span> <span class="n">fit_type</span> <span class="o">=</span> <span class="n">fit_type</span><span class="p">)</span>
    <span class="n">vsd</span> <span class="o">=</span> <span class="n">dds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;vst_counts&quot;</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">dds</span> <span class="p">,</span> <span class="n">vsd</span> <span class="p">,</span> <span class="n">top_genes</span></div>


<div class="viewcode-block" id="data_preprocess">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.data_preprocess">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">data_preprocess</span><span class="p">(</span><span class="n">count_mtx</span> <span class="p">,</span> <span class="n">datMeta</span> <span class="p">,</span> <span class="n">gene_exp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes count matrix data by removing genes with zero expression across all samples.</span>
<span class="sd">    Optionally filters genes based on expression levels and calculates similarity matrices.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        count_mtx (pd.DataFrame): A DataFrame containing the gene count data.</span>
<span class="sd">        datMeta (pd.Series or pd.DataFrame): Metadata associated with the samples in count_mtx.</span>
<span class="sd">        gene_exp (bool): If true, performs additional gene filtering and similarity matrix calculations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The processed count matrix.</span>
<span class="sd">        pd.Series or pd.DataFrame: The corresponding processed metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">n_genes</span> <span class="o">=</span> <span class="n">count_mtx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">count_mtx</span> <span class="o">=</span> <span class="n">count_mtx</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span> <span class="p">,</span> <span class="p">(</span><span class="n">count_mtx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="c1"># remove any genes with all 0 expression</span>
    
    <span class="k">if</span> <span class="n">gene_exp</span> <span class="o">==</span> <span class="kc">True</span> <span class="p">:</span> 
        <span class="n">filtered_genes</span> <span class="o">=</span> <span class="n">filter_genes</span><span class="p">(</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">datMeta</span><span class="p">,</span> <span class="n">lib_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_total_count</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">large_n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_prop</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

        <span class="c1"># Example printing the filtered rows</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Keeping </span><span class="si">%i</span><span class="s2"> genes&quot;</span> <span class="o">%</span> <span class="nb">sum</span><span class="p">(</span><span class="n">filtered_genes</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">%i</span><span class="s2"> genes&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_genes</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">filtered_genes</span><span class="p">)))</span>

        <span class="n">count_mtx</span> <span class="o">=</span> <span class="n">count_mtx</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span> <span class="p">,</span> <span class="n">filtered_genes</span><span class="p">]</span>

        <span class="n">adjacency_matrix</span>  <span class="o">=</span> <span class="n">abs_bicorr</span><span class="p">(</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">mat_means</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">adjacency_matrix</span>  <span class="o">=</span> <span class="n">pearson_corr</span><span class="p">(</span><span class="n">count_mtx</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">mat_means</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">ku</span> <span class="o">=</span> <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zku</span> <span class="o">=</span> <span class="p">(</span><span class="n">ku</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ku</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ku</span><span class="p">))</span>

    <span class="n">to_keep</span> <span class="o">=</span> <span class="n">zku</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">2</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Keeping </span><span class="si">%i</span><span class="s2"> Samples&quot;</span> <span class="o">%</span> <span class="nb">sum</span><span class="p">(</span><span class="n">to_keep</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">%i</span><span class="s2"> Samples&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to_keep</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">to_keep</span><span class="p">)))</span>

    <span class="n">count_mtx</span> <span class="o">=</span> <span class="n">count_mtx</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">to_keep</span><span class="p">]</span>
    <span class="n">datMeta</span> <span class="o">=</span> <span class="n">datMeta</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">to_keep</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">count_mtx</span> <span class="p">,</span> <span class="n">datMeta</span></div>


<div class="viewcode-block" id="custom_cpm">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.custom_cpm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">custom_cpm</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lib_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Counts Per Million (CPM) normalization on count data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        counts (np.array): An array of raw gene counts.</span>
<span class="sd">        lib_size (float or np.array): The total counts in each library (sample).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: Normalized counts expressed as counts per million.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">return</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">lib_size</span> <span class="o">*</span> <span class="mf">1e6</span></div>


<div class="viewcode-block" id="filter_genes">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.filter_genes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_genes</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lib_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_total_count</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">large_n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_prop</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters genes based on several criteria including minimum count thresholds and proportions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        y (np.array): Expression data for the genes.</span>
<span class="sd">        design (np.array, optional): Design matrix for the samples if available.</span>
<span class="sd">        group (np.array, optional): Group information for samples.</span>
<span class="sd">        lib_size (np.array, optional): Library sizes for the samples.</span>
<span class="sd">        min_count (int): Minimum count threshold for including a gene.</span>
<span class="sd">        min_total_count (int): Minimum total count across all samples for a gene.</span>
<span class="sd">        large_n (int): Cutoff for considering a sample &#39;large&#39;.</span>
<span class="sd">        min_prop (float): Minimum proportion used in calculations for large sample consideration.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: Boolean array indicating which genes to keep.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y is not a numeric matrix&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lib_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lib_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">design</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No group or design set. Assuming all samples belong to one group.&quot;</span><span class="p">)</span>
            <span class="n">min_sample_size</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hat_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">design</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">min_sample_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hat_values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">min_sample_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">min_sample_size</span> <span class="o">&gt;</span> <span class="n">large_n</span><span class="p">:</span>
        <span class="n">min_sample_size</span> <span class="o">=</span> <span class="n">large_n</span> <span class="o">+</span> <span class="p">(</span><span class="n">min_sample_size</span> <span class="o">-</span> <span class="n">large_n</span><span class="p">)</span> <span class="o">*</span> <span class="n">min_prop</span>

    <span class="n">median_lib_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lib_size</span><span class="p">)</span>
    <span class="n">cpm_cutoff</span> <span class="o">=</span> <span class="n">min_count</span> <span class="o">/</span> <span class="n">median_lib_size</span> <span class="o">*</span> <span class="mf">1e6</span>

    <span class="n">cpm_values</span> <span class="o">=</span> <span class="n">custom_cpm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lib_size</span><span class="p">)</span>
    <span class="n">keep_cpm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cpm_values</span> <span class="o">&gt;=</span> <span class="n">cpm_cutoff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">min_sample_size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">keep_total_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">min_total_count</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep_cpm</span><span class="p">,</span> <span class="n">keep_total_count</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_similarity_matrix">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.create_similarity_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_similarity_matrix</span><span class="p">(</span><span class="n">mat</span> <span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a similarity matrix from the given data matrix using specified methods.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        mat (pd.DataFrame): The matrix from which to calculate similarities (e.g., gene expression levels).</span>
<span class="sd">        method (str): The method to use for calculating similarities. Supported methods are &#39;bicorr&#39;, &#39;pearson&#39;, and &#39;euclidean&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame representing the similarity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bicorr&#39;</span> <span class="p">:</span> 
        <span class="n">adj</span> <span class="o">=</span> <span class="n">abs_bicorr</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pearson&#39;</span> <span class="p">:</span> 
        <span class="n">adj</span> <span class="o">=</span> <span class="n">pearson_corr</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pearson&#39;</span> <span class="p">:</span> 
        <span class="n">adj</span> <span class="o">=</span> <span class="n">cosine_corr</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">distances</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dist_matrix</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">adj</span></div>


<div class="viewcode-block" id="abs_bicorr">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.abs_bicorr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">abs_bicorr</span><span class="p">(</span><span class="n">data</span> <span class="p">,</span> <span class="n">mat_means</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the absolute bicorrelation matrix for the given data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (pd.DataFrame): Data for which to compute the bicorrelation.</span>
<span class="sd">        mat_means (bool): If True, subtract the mean from each column before computing the correlation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Bicorrelation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">mat_means</span><span class="o">==</span><span class="kc">True</span> <span class="p">:</span> 
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">mat</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">correl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="n">bicorr</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">biweight_midcovariance</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">:</span> 
        <span class="n">correl</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">bicorr</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bicorr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">bicorr</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">correl</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span> <span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="pearson_corr">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.pearson_corr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pearson_corr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mat_means</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Pearson correlation matrix for the given data.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (pd.DataFrame): Data for which to compute the Pearson correlation.</span>
<span class="sd">        mat_means (bool): Normalizes data by its mean if set to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Pearson correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">mat_means</span><span class="o">==</span><span class="kc">True</span> <span class="p">:</span> 
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">/</span> <span class="n">norms</span>

    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">correl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">:</span> 
        <span class="n">correl</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">correl</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span> <span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="cosine_corr">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.cosine_corr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cosine_corr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mat_means</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes cosine correlations for the given data, treated as vectors.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (pd.DataFrame): Data for which to compute cosine correlations.</span>
<span class="sd">        mat_means (bool): If True, normalizes the data before computing correlation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Cosine correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">mat_means</span><span class="o">==</span><span class="kc">True</span> <span class="p">:</span> 
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">/</span> <span class="n">norms</span>

    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">correl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">:</span> 
        <span class="n">correl</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="n">i</span> <span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">correl</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span> <span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="knn_graph_generation">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.knn_graph_generation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">knn_graph_generation</span><span class="p">(</span><span class="n">datExpr</span> <span class="p">,</span> <span class="n">datMeta</span> <span class="p">,</span> <span class="n">knn</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span> <span class="p">,</span><span class="n">extracted_feats</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a k-nearest neighbor graph based on the specified data and method of similarity.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        datExpr (pd.DataFrame): DataFrame containing expression data or other numerical data.</span>
<span class="sd">        datMeta (pd.DataFrame or pd.Series): Metadata for the nodes in the graph.</span>
<span class="sd">        knn (int): Number of nearest neighbors to connect to each node.</span>
<span class="sd">        method (str): Method used for calculating similarity or distance (&#39;euclidean&#39;, &#39;bicorr&#39;, &#39;pearson&#39;, &#39;cosine&#39;).</span>
<span class="sd">        extracted_feats ([type]): Specific features extracted from the data to use for graph construction.</span>
<span class="sd">        **args: Additional arguments for customizing the node visualization (e.g., `node_colour`, `node_size`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        nx.Graph: A NetworkX graph object representing the k-nearest neighbors graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">extracted_feats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="n">mat</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span> <span class="p">,</span> <span class="n">extracted_feats</span><span class="p">]</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">mat</span> <span class="o">=</span> <span class="n">datExpr</span>
        
    <span class="n">adj</span> <span class="o">=</span> <span class="n">create_similarity_matrix</span><span class="p">(</span><span class="n">mat</span> <span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="s1">&#39;node_colour&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">:</span> 
        <span class="n">node_colour</span> <span class="o">=</span> <span class="n">datMeta</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span><span class="n">wesanderson</span><span class="o">.</span><span class="n">FantasticFox2_5</span><span class="o">.</span><span class="n">hex_colors</span> <span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">node_colour</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;node_colour&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;node_size&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">:</span> 
        <span class="n">node_size</span> <span class="o">=</span> <span class="mi">300</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">node_size</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;node_size&#39;</span><span class="p">]</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">plot_knn_network</span><span class="p">(</span><span class="n">adj</span> <span class="p">,</span> <span class="n">knn</span> <span class="p">,</span> <span class="n">datMeta</span> <span class="p">,</span> <span class="n">node_colours</span><span class="o">=</span><span class="n">node_colour</span> <span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="get_k_neighbors">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.get_k_neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_k_neighbors</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">k</span> <span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds k-nearest neighbors for each row in the given matrix.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        matrix (pd.DataFrame): The matrix from which neighbors are to be found.</span>
<span class="sd">        k (int): The number of neighbors to find for each row.</span>
<span class="sd">        corr (bool): Indicates whether to use correlation rather than distance for finding neighbors.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where keys are indices (or node names) and values are lists of k-nearest neighbors&#39; indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">dist_mtx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">values</span> <span class="p">,</span>  <span class="n">matrix</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">dist_mtx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dist_mtx</span> <span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="c1">#if corr == True : </span>
    <span class="c1">#    matrix.loc[: , :] = 1 - matrix.values</span>
    
    <span class="n">k_neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">dist_mtx</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">dist_mtx</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Exclude the node itself</span>
        <span class="n">k_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbors</span>
        
    <span class="k">return</span> <span class="n">k_neighbors</span></div>


<div class="viewcode-block" id="plot_knn_network">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.plot_knn_network">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_knn_network</span><span class="p">(</span><span class="n">data</span> <span class="p">,</span> <span class="n">K</span> <span class="p">,</span> <span class="n">labels</span> <span class="p">,</span>  <span class="n">node_colours</span> <span class="o">=</span> <span class="s1">&#39;skyblue&#39;</span> <span class="p">,</span> <span class="n">node_size</span> <span class="o">=</span> <span class="mi">300</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a k-nearest neighbors network using NetworkX.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (pd.DataFrame): The similarity or distance matrix used to determine neighbors.</span>
<span class="sd">        K (int): The number of nearest neighbors for network connections.</span>
<span class="sd">        labels (pd.Series): Labels or categories for the nodes used in plotting.</span>
<span class="sd">        node_colours (str or list): Color or list of colors for the nodes.</span>
<span class="sd">        node_size (int): Size of the nodes in the plot.</span>

<span class="sd">    Returns:</span>
<span class="sd">        nx.Graph: A NetworkX graph object that has been plotted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get k-nearest neighbors for each node (k=20 in this example)</span>
    <span class="n">k_neighbors</span> <span class="o">=</span> <span class="n">get_k_neighbors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>

    <span class="c1"># Create a NetworkX graph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

    <span class="c1"># Add nodes to the graph</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span> <span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span> <span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span> <span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">))</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;idx&#39;</span><span class="p">)</span>

    <span class="c1"># Add edges based on the k-nearest neighbors</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">k_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">node_colours</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_colours</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span> <span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="p">:</span> 
        <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lab</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">patches</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="check_wall_names">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.check_wall_names">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_wall_names</span><span class="p">(</span><span class="n">wall</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether all matrices in a list share the same row and column names.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        wall (list of pd.DataFrame): List of matrices to check.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Returns True if all matrices have consistent names, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span><span class="w"> </span><span class="nf">name_match</span><span class="p">(</span><span class="n">names_a</span><span class="p">,</span> <span class="n">names_b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">names_a</span><span class="p">,</span> <span class="n">names_b</span><span class="p">)</span>

    <span class="n">first_names_a</span><span class="p">,</span> <span class="n">first_names_b</span> <span class="o">=</span> <span class="n">wall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">wall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">name_match</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">first_names_a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_match</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">first_names_b</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">)</span></div>


<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.normalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizes a square matrix by scaling each row by its total minus the diagonal value, handling it in-place.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x (np.array): The square matrix to normalize.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: The normalized matrix with diagonal set to 0.5.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">row_sum_mdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">row_sum_mdiag</span><span class="p">[</span><span class="n">row_sum_mdiag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">row_sum_mdiag</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="SNF">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.SNF">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SNF</span><span class="p">(</span><span class="n">networks</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs Similarity Network Fusion over multiple networks.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        networks (list of pd.DataFrames): The individual networks to fuse, represented as similarity or distance matrices.</span>
<span class="sd">        K (int): Number of nearest neighbors to retain in the diffusion process.</span>
<span class="sd">        t (int): Number of iterations for the fusion process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A fused network represented as a similarity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">wall</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">wall_name_check</span> <span class="o">=</span> <span class="n">check_wall_names</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span>
    <span class="n">wall_names</span> <span class="o">=</span> <span class="n">wall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">wall</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span>  <span class="c1"># Assuming wall_names are indices corresponding to dimnames in R</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">wall_name_check</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dim names not consistent across all matrices in wall.</span><span class="se">\n</span><span class="s2">Returned matrix will have no dim names.&quot;</span><span class="p">)</span>

    <span class="n">lw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lw</span><span class="p">):</span>
        <span class="n">wall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">convert_dataframe_to_numpy</span><span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">wall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">wall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">new_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">dominateset</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">]</span>  <span class="c1"># You need to implement this function</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">next_w</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lw</span><span class="p">):</span>
            <span class="n">sum_wj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lw</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">sum_wj</span> <span class="o">+=</span> <span class="n">wall</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">next_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_w</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">@</span> <span class="p">(</span><span class="n">sum_wj</span> <span class="o">/</span> <span class="p">(</span><span class="n">lw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">@</span> <span class="n">new_w</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lw</span><span class="p">):</span>
            <span class="n">wall</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">next_w</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">wall</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">wall</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wall</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">wall</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">+=</span> <span class="n">m</span>
    <span class="n">w</span> <span class="o">/=</span> <span class="n">lw</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">wall_name_check</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">w</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">wall_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">wall_names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># Not valid Python, handling similar to dimnames needs custom structuring</span>

    <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="dominateset">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.dominateset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dominateset</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">KK</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts a dominant set from a similarity matrix, setting all but the top KK connections per row to zero and re-normalizes rows.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        xx (np.array or pd.DataFrame): The input similarity or distance matrix.</span>
<span class="sd">        KK (int): Number of top values to keep in each row of the matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: The extracted dominant set matrix with top KK neighbors per row.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Get indices that would sort x</span>
        <span class="n">x</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">[:</span><span class="o">-</span><span class="n">KK</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1"># Set all but the top KK values to zero</span>
        <span class="k">return</span> <span class="n">x</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="n">row_sums</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_sums</span><span class="p">[</span><span class="n">row_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>     <span class="c1"># To avoid division by zero</span>
        <span class="k">return</span> <span class="n">X</span> <span class="o">/</span> <span class="n">row_sums</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>  <span class="c1"># Use copy to avoid modifying the original matrix</span>
    
    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_dataframe_to_numpy">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.convert_dataframe_to_numpy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convert_dataframe_to_numpy</span><span class="p">(</span><span class="n">input_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a pandas DataFrame to a numpy array. If the input is not a DataFrame, returns it as is.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        input_data (pd.DataFrame or any): Data to be converted to numpy array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array or original data type: The resulting numpy array from conversion or the original input if conversion isn&#39;t applicable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># Convert the DataFrame to a numpy array using .to_numpy()</span>
        <span class="k">return</span> <span class="n">input_data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&quot;The provided input is not a pandas DataFrame.&quot;)</span>
        <span class="k">return</span> <span class="n">input_data</span></div>

    
<div class="viewcode-block" id="gen_new_graph">
<a class="viewcode-back" href="../MOGDx/MAIN/Preprocess_Functions.html#preprocess_functions.gen_new_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_new_graph</span><span class="p">(</span><span class="n">model</span> <span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">meta</span> <span class="p">,</span> <span class="n">pnet</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="p">:</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a new graph from learned features using a provided model, handling multi-modal data and integrating them.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        model (nn.Module): The trained model which contains the learned parameters.</span>
<span class="sd">        h (torch.Tensor): Tensor containing features of the data.</span>
<span class="sd">        meta (pd.DataFrame or pd.Series): Metadata associated with the features.</span>
<span class="sd">        pnet (bool): Flag indicating whether or not pathway network transformations have been used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        nx.Graph: A graph object representing the new graph generated from the features.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    
    <span class="n">full_graphs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">prev_dim</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="p">,</span> <span class="p">(</span><span class="n">Encoder</span> <span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">encoder_dims</span> <span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span> <span class="p">:</span> 
        <span class="c1">#feats = np.argsort(abs(encoding_model.encoder[0].weight.mean(axis =0)).detach().cpu().numpy())</span>
        <span class="c1">#lin_features = h[i][: , feats[-int(len(feats)*0.1):]].detach().cpu().numpy()</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="p">[:</span> <span class="p">,</span> <span class="n">prev_dim</span><span class="p">:</span><span class="n">dim</span><span class="o">+</span><span class="n">prev_dim</span><span class="p">]</span>
        <span class="n">nan_rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pnet</span> <span class="p">:</span> 
            <span class="n">first_layer_feat</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">nan_rows</span><span class="p">]</span> <span class="o">@</span> <span class="n">Encoder</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">first_layer_feat</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">nan_rows</span><span class="p">]</span> <span class="o">@</span> <span class="n">Encoder</span><span class="o">.</span><span class="n">encoder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                
        <span class="n">mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">first_layer_feat</span> <span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">nan_rows</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">node_labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="n">create_similarity_matrix</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">)</span>
        
        <span class="c1"># Get k-nearest neighbors for each node (k=20 in this example)</span>
        <span class="n">k_neighbors</span> <span class="o">=</span> <span class="n">get_k_neighbors</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>

        <span class="c1"># Create a NetworkX graph</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="c1"># Add nodes to the graph</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Add edges based on the k-nearest neighbors</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">k_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

        <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">df_tmp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_pandas_adjacency</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">df_tmp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">node_labels</span>
        <span class="n">df_tmp</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">node_labels</span>

        <span class="n">df_full</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_tmp</span><span class="o">.</span><span class="n">index</span> <span class="p">,</span> <span class="n">df_tmp</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_tmp</span><span class="o">.</span><span class="n">values</span>

        <span class="n">full_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_full</span><span class="p">)</span>
        
        <span class="n">prev_dim</span> <span class="o">+=</span> <span class="n">dim</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_graphs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span> 
        <span class="n">adj_snf</span> <span class="o">=</span> <span class="n">SNF</span><span class="p">(</span><span class="n">full_graphs</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">adj_snf</span> <span class="o">=</span> <span class="n">full_graphs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">node_colour</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adj_snf</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span><span class="n">wesanderson</span><span class="o">.</span><span class="n">FantasticFox2_5</span><span class="o">.</span><span class="n">hex_colors</span> <span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">plot_knn_network</span><span class="p">(</span><span class="n">adj_snf</span> <span class="p">,</span> <span class="n">K</span> <span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adj_snf</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="p">,</span>
                                                   <span class="n">node_colours</span><span class="o">=</span><span class="n">node_colour</span> <span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">G</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z09VV2YFE0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Z09VV2YFE0', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>